require 'ostruct'
require 'optparse'
require 'stringio'

module Spec
  module Runner
    class OptionParser
      BUILT_IN_FORMATTERS = {
        'specdoc'  => Formatter::SpecdocFormatter,
        's'        => Formatter::SpecdocFormatter,
        'html'     => Formatter::HtmlFormatter,
        'h'        => Formatter::HtmlFormatter,
        'rdoc'     => Formatter::RdocFormatter,
        'r'        => Formatter::RdocFormatter,
        'progress' => Formatter::ProgressBarFormatter,
        'p'        => Formatter::ProgressBarFormatter,
        'failing_examples' => Formatter::FailingExamplesFormatter,
        'e'        => Formatter::FailingExamplesFormatter
      }

      def initialize
        @spec_parser = SpecParser.new
        @file_factory = File
      end

      def create_behaviour_runner(args, err, out, warn_if_no_files)
        options = parse(args, err, out, warn_if_no_files)
        # Some exit points in parse (--generate-options, --drb) don't return the options, 
        # but hand over control. In that case we don't want to continue.
        return nil unless options.is_a?(OpenStruct)

        options.formatters.each do |formatter|
          formatter.colour = options.colour
          formatter.dry_run = options.dry_run
        end
        options.reporter = Reporter.new(options.formatters, options.backtrace_tweaker, options.failure_file) 

        # this doesn't really belong here.
        # it should, but the way things are coupled, it doesn't
        if options.differ_class
          Spec::Expectations.differ = options.differ_class.new(options.diff_format, options.context_lines, options.colour)
        end

        unless options.generate
          if options.runner_type
            options.runner_type.new(options)
          else
            BehaviourRunner.new(options)  
          end
        end
      end

      def parse(args, err, out, warn_if_no_files)
        options_file = nil
        args_copy = args.dup
        options = OpenStruct.new
        options.formatters = []
        options.backtrace_tweaker = QuietBacktraceTweaker.new
        options.examples = []

        opts = ::OptionParser.new do |opts|
          opts.banner = "Usage: spec (FILE|DIRECTORY|GLOB)+ [options]"
          opts.separator ""

          opts.on("-D", "--diff [FORMAT]", "Show diff of objects that are expected to be equal when they are not",
                                           "Builtin formats: unified|u|context|c",
                                           "You can also specify a custom differ class",
                                           "(in which case you should also specify --require)") do |format|

            # TODO make context_lines settable
            options.context_lines = 3

            case format
              when 'context', 'c'
                options.diff_format  = :context
              when 'unified', 'u', '', nil
                options.diff_format  = :unified
            end

            if [:context,:unified].include? options.diff_format
              require 'spec/expectations/differs/default'
              options.differ_class = Spec::Expectations::Differs::Default
            else
              begin
                options.diff_format  = :custom
                options.differ_class = eval(format)
              rescue NameError
                err.puts "Couldn't find differ class #{format}"
                err.puts "Make sure the --require option is specified *before* --diff"
                exit if out == $stdout
              end
            end

          end
          
          opts.on("-c", "--colour", "--color", "Show coloured (red/green) output") do
            options.colour = true
          end
          
          opts.on("-e", "--example [NAME|FILE_NAME]", "Execute example(s) with matching name(s). If the argument is",
                                                      "the path to an existing file (typically generated by a previous",
                                                      "run using --format failing_examples:file.txt), then the examples",
                                                      "on each line of thatfile will be executed. If the file is empty,",
                                                      "all examples will be run (as if --example was not specified).",
                                                      " ",
                                                      "If the argument is not an existing file, then it is treated as",
                                                      "an example name directly, causing RSpec to run just the example",
                                                      "matching that name") do |example|
            if(File.file?(example))
              options.examples = File.open(example).read.split("\n")
            else
              options.examples = [example]
            end
          end

          opts.on("-l", "--line LINE_NUMBER", Integer, "Execute behaviout or specification at given line.",
                                                       "(does not work for dynamically generated specs)") do |line_number|
            options.line_number = line_number.to_i
          end

          opts.on("-f", "--format FORMAT[:FILE_NAME]",  "Specifies what format to use for output. The output is written",
                                                        "to standard out unless FILE_NAME is specified. The --format option",
                                                        "may be specified several times if you want several outputs",
                                                        " ",
                                                        "Builtin formats: ",
                                                        "progress|p         : Text progress", 
                                                        "specdoc|s          : Behaviour doc as text", 
                                                        "rdoc|r             : Behaviour doc as RDoc", 
                                                        "html|h             : A nice HTML report", 
                                                        "failing_examples|e : Create input for --example", 
                                                        " ",
                                                        "FORMAT can also be the name of a custom formatter class",
                                                        "(in which case you should also specify --require)") do |format|
            
            format_out = out
            # This funky regexp checks whether we have a FILE_NAME or not
            if (format =~ /([a-zA-Z_]+(?:::[a-zA-Z_]+)*):?(.*)/) && ($2 != '')
              format = $1
              format_out = File.open($2, 'w')
            else
              raise "When using several --format options only one of them can be without a file" if @out_used
              @out_used = true
            end

            begin
              formatter_type = BUILT_IN_FORMATTERS[format] || eval(format)
              options.formatters << formatter_type.new(format_out)
            rescue NameError
              err.puts "Couldn't find formatter class #{format}"
              err.puts "Make sure the --require option is specified *before* --format"
              exit if out == $stdout
            end
          end

          opts.on("-r", "--require FILE", "Require FILE before running specs",
                                          "Useful for loading custom formatters or other extensions",
                                          "If this option is used it must come before the others") do |req|
            req.split(",").each{|file| require file}
          end
          
          opts.on("-b", "--backtrace", "Output full backtrace") do
            options.backtrace_tweaker = NoisyBacktraceTweaker.new
          end
          
          opts.on("-L", "--loadby STRATEGY", "Specify the strategy by which spec files should be loaded.",
                                              "STRATEGY can currently only be 'mtime' (File modification time)",
                                              "By default, spec files are loaded in alphabetical order if --loadby",
                                              "is not specified.") do |loadby|
            options.loadby = loadby
          end

          opts.on("-R", "--reverse", "Run examples in reverse order") do
            options.reverse = true
          end
          
          opts.on("-t", "--timeout FLOAT", "Interrupt and fail each example that doesn't complete in the",
                                             "specified time") do |timeout|
            options.timeout = timeout.to_f
          end

          opts.on("-H", "--heckle CODE", "If all examples pass, this will run your examples many times, mutating",
                                         "the specced code a little each time. The intent is that examples",
                                         "*should* fail, and RSpec will tell you if they don't.",
                                         "CODE should be either Some::Module, Some::Class or Some::Fabulous#method}") do |heckle|
            heckle_runner = PLATFORM == 'i386-mswin32' ? 'spec/runner/heckle_runner_win' : 'spec/runner/heckle_runner'
            require heckle_runner
            options.heckle_runner = HeckleRunner.new(heckle)
          end
          
          opts.on("-d", "--dry-run", "Don't execute examples") do
            options.dry_run = true
          end
          
          opts.on("-O", "--options PATH", "Read options from a file") do |options_file|
            # Remove the --options option and the argument before writing to file
            index = args_copy.index("-O") || args_copy.index("--options")
            args_copy.delete_at(index)
            args_copy.delete_at(index)

            new_args = args_copy + IO.readlines(options_file).map {|l| l.chomp.split " "}.flatten
            return CommandLine.run(new_args, err, out, true, warn_if_no_files)
          end

          opts.on("-G", "--generate-options PATH", "Generate an options file for --options") do |options_file|
            # Remove the --generate-options option and the argument before writing to file
            index = args_copy.index("-G") || args_copy.index("--generate-options")
            args_copy.delete_at(index)
            args_copy.delete_at(index)

            File.open(options_file, 'w') do |io|
              io.puts args_copy.join("\n")
            end
            out.puts "\nOptions written to #{options_file}. You can now use these options with:"
            out.puts "spec --options #{options_file}"
            options.generate = true
          end

          opts.on("-U", "--runner RUNNER", "Use a custom BehaviourRunner") do |runner|
            begin
              options.runner_type = eval(runner)
            rescue NameError
              err.puts "Couldn't find behaviour runner class #{runner}"
              err.puts "Make sure the --require option is specified."
              exit if out == $stdout
            end
          end
          
          opts.on("-X", "--drb", "Run examples via DRb. (For example against script/spec_server)") do |options_file|
            # Remove the --drb option
            index = args_copy.index("-X") || args_copy.index("--drb")
            args_copy.delete_at(index)
            
            return DrbCommandLine.run(args_copy, err, out, true, warn_if_no_files)
          end

          opts.on("-v", "--version", "Show version") do
            out.puts ::Spec::VERSION::DESCRIPTION
            exit if out == $stdout
          end

          opts.on_tail("-h", "--help", "You're looking at it") do
            out.puts opts
            exit if out == $stdout
          end
          
        end
        opts.parse!(args)

        if args.empty? && warn_if_no_files
          err.puts "No files specified."
          err.puts opts
          exit(6) if err == $stderr
        end

        if options.line_number
          set_spec_from_line_number(options, args, err)
        end
        
        if options.formatters.empty?
          options.formatters << Formatter::ProgressBarFormatter.new(out)
        end

        options
      end
      
      def set_spec_from_line_number(options, args, err)
        if options.examples.empty?
          if args.length == 1
            if @file_factory.file?(args[0])
              source = @file_factory.open(args[0])
              example = @spec_parser.spec_name_for(source, options.line_number)
              options.examples = [example]
            elsif @file_factory.directory?(args[0])
              err.puts "You must specify one file, not a directory when using the --line option"
              exit(1) if err == $stderr
            else
              err.puts "#{args[0]} does not exist"
              exit(2) if err == $stderr
            end
          else
            err.puts "Only one file can be specified when using the --line option: #{args.inspect}"
            exit(3) if err == $stderr
          end
        else
          err.puts "You cannot use both --line and --example"
          exit(4) if err == $stderr
        end
      end
    end
  end
end
